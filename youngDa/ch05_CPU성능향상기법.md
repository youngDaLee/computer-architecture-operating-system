# ch05. CPU 성능 향상 기법
## 5-1 빠른 CPU를 위한 설계 기법
### 클럭
1. 컴퓨터 부품들은 클럭신호에 맞춰 움직임
2. cpu는 명령어 사이클 이라는 정해진 신호에 맞춰 명령어 실행

클럭 속도가 높은 cpu는 성능이 좋음. -> 클럭속도=CPU속도단위
- 클럭속도를 Hz(헤르츠)단위로 측정. 1초에 클럭이 몇번 반복되는지
- 클럭속도를 높인다고 CPU가 무조건 빨라지는 것은 아님

### 코어와 멀티코어
- 멀티코어CPU(멀티코어 프로세서) : 코어를 여러 개 포함하고 있는 CPU
  - CPU 연산 속도가 코어 수에 비례해서 증가하지는 않음
  - 처리하고자 하는 작업량보다 코어 지나치게 많아도 성능에 큰 영향 없음
  - 코어마다 처리할 명령 얼마나 적절하게 분배하느냐가 중요


### 스레드와 멀티스레드
스레드 : 실행흐름 단위(CPU의 스레드와 프로그래밍 스레드는 다르다)


하드웨어적 스레드
- 하나의 코어가 동시에 처리하는 명령어 단위
- 여러 스레드를 지원하는 CPU는 하나으 ㅣ코어로도 여러 명령어를 동시에 실행 가능
- 하이퍼스레딩 : 인텔의 멀티스레딩 기술


소프트웨어적 스레드
- 하나의 프로그램에서 독립적으로 실행하는 단위


멀티스레드 프로세서
- 하나의 코어로 여러 명령어 동시에 처리하도록 하려면 명령어를 처리하느 레지스터를 여러 개 가지고 있으면 됨
- 2코어 4스레드 CPU는 한 번에 4개의 명령어를 처리 가능
  - **논리프로세서**

## 5-2 명령어 병렬 처리 기법
CPU가 놀지 않고 시간을 알뜰하게 쓰며 작동하게 만드는 것도 중요

### 명령어 파이프라인
명령어 처리 과정을 클럭단위로 나눈 것
1. 명령어 인출(Instruction Fetch)
2. 명령어 해석(Instruction Decode)
3. 명령어 실행(Execute Instruction)
4. 결과 저장(Write Back)

단계가 겹치지 않는다면 cpu는 각 단계를 동시에 실행 가능함.    
명령어들을 명령어 파이프라인에 넣고 동시에 처리하는 기법을 명령어 파이프라이닝이라 함

파이프라인 위험 : 특정 상황에서 성능 향상에 실패하는 경우
- 데이터 위험 : 명령어간 데이터 의존성에 의해 발생
- 제어 위험 : 분기 등으로 인한 프로그램카운터의 갑작스러운 변화 -> 해결 위해 분기예측 사용
- 구조적 위험 : 서로 다른 명령어가 동시에 ALU, 레지스터 등과 같은 CPU 부품을 사용하려 할 때 발생(자원위험)

### 슈퍼스칼라
CPU 내부에 여러 명령어 파이프라인을 포함한 구조
- 슈퍼스칼라 구조로 명령어 처리가 가능한 cpu를 슈퍼스칼라 프로세서(cpu)라 함
- 슈퍼스칼라 프로세스를 사용하면 프로그램 처리 속도가 빨라짐
- 대신 데이터위험, 제어위험, 자원위험을 피하기 까다로워짐

### 비순차적 명령어 처리
명령어를 순차적으로 처리하지 않는 기법(합법적 새치기)
- 파이프라인 중단 방지를 위해 명령어 순차 처리 하지 않는 방식

## 5-3 CISC와 RISC
### 명령어 집합(Instruction Set Architecture, ISA)
CPU가 이해할 수 있는 명령어의 모음. 
- ex) 인텔의 x86, ...
- ISA가 다르면 CPU가 이해할 수 있는 명령어, 어셈블리어도 달라짐

명령어 병렬처리 기법을 도입하기 유리한 ISA : CISC, RISC
### CISC(Complex Instruction Set Computer)
복잡한 명령어 집합을 활용하는 컴퓨터(CPU)
- 가변 길이 명령어를 사용
- 대표ISA : x86, x86-64
- 메모리를 아끼며 개발해야 했던 시절 인기가 ㅁ나항ㅆ음
- 활용허눈 명령어가 복잡하고 다양한 기능을 제공하는 탓에 명령어 크기와 실행 시간이 일정하지 않음 -> 명령어 파이프라인에 걸림돌
  
=> 복잡하고 다양항 기능 제공하기 때문에적은 수의 명령으로 프로그램 동작시키고 메모리 절약 가능. 명령어 규격화 어렵기 때문에 파이프라이닝이 어려워 복잡한 명령어는 사용빈도가 낮음. 성장 한계가 있음


CISC의 한계
1. 빠른 처리를 위해 명령어 파이프라인을 활용해야 함. 원활한 파이프라이닝을 위해 '명령어 길이와 수행시간이 짧고 규격화 ' 되어 있어야 함
2. 어차피 자주 쓰이는 명령어만 사용되기 때문에, 복잡한 기능 명령 추가보다는 자주 쓰이는 기본 명령어를 작고 빠르게 만드는게 중요


### RISC(Reduced Instruction Set Computer)
짧고 규격화된 명령어(1클럭 내외) 지향. 명령어 종류가 적음
- 고정길이 명령어 활용
- 명령어 파이프라이닝이 최적화됨
- 메모리에 직접 접근하는 명령어를 load, store 두 개로 제한 -> 메모리 접근 단순화하고 최소화함
- 레지스터 적극활용 -> 레지스터 이용하는 연산이 많음. 일반적인 경우 범용레지스터 개수도 더 많음.
- 사용가능한 명령어가 CISC에 비해 적어 더 많은 명령으로 프로그램을 작동시킴
- 대표 ISA : arm


# 내 생각
arm과 x86_64 차이를 잘 몰랐는데(대충 OS별로 차이인줄만 알았음) 이번 기회에 어느 정도 대표적으로 어떤 차이가 있는지 알게 되었다.

# 논의할 내용
어떤 경우에 RISC를 쓰고, 어떤 경우에 CISC를 써야 할까? AWS에서 인스턴스 생성할 때 이 부분을 알아두면 유용할 것 같다.
